#!/bin/sh

usage() {
  cat <<USAGE
usage: git fork update [<branch_name>] [-A|--all] [-q|--quiet]

Arguments:
  <branch_name>   Directory to clone the fork to.
                  Defaults to the current directory.

Options:
  -o <origin>     URI of a remote to host your fork at.
  -q | --quiet    Suppresses output.
USAGE
}

help() {
  usage; cat <<HELP
HELP
}

cmd_help() {
  help; exit 0
}

cmd_update(){

  INITIAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)

  # Assert the existance of a <source> remote with <master> branch, or fail
  if [[ -n "$(git ls-remote source master)" ]]; then

    # Until parameter doesn't exist or is an option
    until [ -z "$1" ] || [[ $1 = -* ]]; do
      # add it as a branch name
      BRANCHES="$BRANCHES $1"; shift
    done

    parse_opts "$@"

    output 'Updating master from <source>...'
    execute "git checkout master"
    execute "git pull source master"

echo "$BRANCHES"

    # If ALL is set
    if [ -n "$ALL" ]; then
      # update all branches
      for branch in $(git for-each-ref --format='%(refname:short)' refs/heads/); do
        rebase_branch $branch
      done

    # else if branches were provided
    elif [ -n "$BRANCHES" ]; then
      # update those branches
      for branch in $BRANCHES; do
        rebase_branch $branch
      done
    fi

    # else updating master suffices.

    execute "git checkout $INITIAL_BRANCH"
    exit 0

  else
    echo 'git-fork expects a branch named <master> in a remote named <source>.'
    echo 'Please add one to continue.'
    exit 1
  fi

}

parse_opts() {
  while getopts ":A,all,q,quiet" option
  do
    case "$option" in
      A | all)
        ALL=true
        ;;
      q | quiet)
        QUIET=true
        ;;
      *)
        usage; exit 1
        ;;
    esac
  done
}
