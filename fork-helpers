#!/bin/sh

output() {
  if [[ -z "$QUIET" ]]; then
    echo $1
  fi
}

# This shit is why Aspect oriented programming exists.
execute() {
  if [[ -z "$QUIET" ]]; then
    eval "$1"
  else
    eval "$1 -q"
  fi
}

get_git_dir_name() {
  # Ask me not what this incantation means,
  # For I learned it from a wizard
  # Who heard it from a witch
  # Who spent 40 minutes dicking around in her terminal
  # Unitl it worked.
  # All I knowst
  # Is that it strippith the repo name
  # From an http://github.com/user/repo_name/
  # Or a git@github.com/user/repo_name.git URI
  # Sans prejudice.
  DIR_NAME=$(echo $1 | grep -Eo '\/.+?(\/)?(.\git)?$' | grep -Eo '[^\/].+[^\/][^\.git]')
}

rebase_branch() {
  # Skip master
  if [ $1 != 'master' ]; then
    # Ensure branch exists
    if [[ -n "$(git show-ref refs/heads/$1)" ]]; then
      output "Updating branch $1..."
      execute "git checkout $1 -q"
      execute "git rebase master"
    else
      output "Branch $1 not found. Skipping."
    fi
  fi
}

submit_branch() {
  # Skip master
  if [ $1 != 'master' ]; then
    # Ensure branch exists
    if [[ -n "$(git show-ref refs/heads/$1)" ]]; then
      execute "git fork update $1"
      execute "git checkout $1"
      execute "git push $2 $1"
    else
      output "Branch $1 not found. Skipping."
    fi
  fi
}

local_only_branches() {
  BRANCHES=""
  # List local branches by name
  LOCAL=$(git for-each-ref --format='%(refname:short)' refs/heads/)
  # List source branches by source/name
  SOURCE=$(git for-each-ref --format='%(refname:short)' refs/remotes/source/)
  for local in $LOCAL; do
    # If branch is not found in source
    if [[ -z $(echo $SOURCE | grep -Eo "\bsource\/$local\b") ]]; then
      # add to local only list
      BRANCHES="$local $BRANCHES"
    fi
  done
}
