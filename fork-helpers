#!/bin/sh

output() {
  if [[ -z "$QUIET" ]]; then
    echo $1
  fi
}

# This shit is why Aspect oriented programming exists.
execute() {
  if [[ -z "$QUIET" ]]; then
    eval "$1"
  else
    eval "$1 -q"
  fi
}

line_count() {
  if [[ -z "$1" ]]; then
    echo '0'
  else
    echo "$1" | sed '/^\s*$/d' | wc -l | tr -d ' '
  fi
}

branch_exists() {
  echo $(git show-ref refs/heads/$1)
}

branches_matching() {
  echo $(git for-each-ref --format='%(refname:short)' $1)
}

current_branch() {
  echo $(git rev-parse --abbrev-ref HEAD)
}

commit_count() {
  line_count "$(git rev-list $1..$2)"
}

present_behind() {
  local diff=$(commit_count $1 $2)
  if [[ $diff = '0' ]]; then
    echo "up to date with $2"
  else
    echo "behind $2 by $diff commits"
  fi
}

present_ahead() {
  local diff=$(commit_count $1 $2)
  if [[ $diff = '0' ]]; then
    echo "up to date with $1"
  else
    echo "ahead of $1 by $diff commits"
  fi
}

checkout() {
  # Only checkout if neccesary. Saves some time.
  if [[ $1 != $(current_branch) ]]; then
    execute "git checkout $1"
  fi
}

get_git_dir_name() {
  # Ask me not what this incantation means,
  # For I learned it from a wizard
  # Who heard it from a witch
  # Who spent 40 minutes dicking around in her terminal
  # Unitl it worked.
  # All I knowst
  # Is that it strippith the repo name
  # From an http://github.com/user/repo_name/
  # Or a git@github.com/user/repo_name.git URI
  # Sans prejudice.
  echo $1 | grep -Eo '\/.+?(\/)?(.\git)?$' | grep -Eo '[^\/].+[^\/][^\.git]'
}

local_only_branches() {
  local branches=""
  # List local branches by name
  local local_branches=$(branches_matching refs/heads/)
  # List source branches by source/name
  local source_branches=$(branches_matching refs/remotes/source/)
  for local in $local_branches; do
    # If branch is not found in source
    if [[ -z $(echo $source_branches | grep -Eo "\bsource\/$local\b") ]]; then
      # add to local only list
      branches="$local $branches"
    fi
  done
  echo $branches
}

branch_status() {
  # Skip master
  if [[ "$1" != 'master' ]]; then
    # Ensure branch exists
    if [[ -n $(branch_exists $1) ]]; then
      local behind_master=$(present_behind $1 master)
      local behind_source=$(present_behind $1 source/master)
      local ahead_remote=''
      # Try remote
      if [[ -n "$2" ]] && [[ -n $(branches_matching "refs/remotes/$2/$1") ]]; then
        ahead_remote=$(present_ahead $2/$1 $1)
      else
        ahead_remote="submission status unkown"
      fi
      output "$1: $behind_master, $behind_source, $ahead_remote."
    else
      output "Branch $1 not found. Skipping."
    fi
  fi
}

rebase_branch() {
  # Skip master
  if [ $1 != 'master' ]; then
    # Ensure branch exists
    if [[ -n $(branch_exists $1) ]]; then
      # If branch needs rebase
      if [[ $(commit_count $1 master) != '0' ]]; then
        output "Updating branch $1..."
        checkout "$1 -q"
        execute "git rebase master"
      else
        output "Branch $1 is already up to date."
      fi
    else
      output "Branch $1 not found. Skipping."
    fi
  fi
}

submit_branch() {
  # Skip master
  if [ $1 != 'master' ]; then
    # Ensure branch exists
    if [[ -n $(branch_exists $1) ]]; then
      execute "git fork update $1"
      # If branch needs to be submitted
      if [[ $(commit_count $2/$1 $1) != '0' ]]; then
        checkout "$1"
        execute "git push $2 $1"
      else
        output "Branch $1 is already submitted."
      fi
    else
      output "Branch $1 not found. Skipping."
    fi
  fi
}
